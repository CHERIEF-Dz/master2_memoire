#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extreport
\begin_preamble
\usepackage{algpseudocode}
\end_preamble
\use_default_options true
\begin_modules
enumitem
figs-within-sections
tabs-within-sections
eqs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tbph
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch BiblioInEachChapter
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
State of art and our proposed approach
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In recent years, the vast energy consumption generated by cloud data centers
 has attracted wide attention from society.
 Relevant survey data show that electricity demand in US data centers has
 increased from 29 billion kWh in 2000 to nearly 73 billion kWh in 2020.
 The computing device will also increase the thermal load while using electric
 energy.
 The thermal load of a single rack will reach 50 kW in 2025.
 In addition, it also leads to the decline of quality of service (QoS) and
 environmental deterioration, which runs counter to the concept of green
 sustainable development.
 Therefore, achieving energy conservation and emission reduction is the
 key to developing the next generation of green data centers
\begin_inset CommandInset citation
LatexCommand cite
key "CHEN2023"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
In this chapter, will present EViMA algorithm which is used for improving
 resource management in the cloud data center to obtain the best task schedules
 that reduces energy consumption, execution makespan and cost without violating
 deadline constraints.Then will introduce VM placement and VM consolidation
 problem and its 4 sub-problems and for each sub problem some of the most
 used methods to find the solutions.
 And finally we will present the objectives, the concept of our approach
 and also its description, and explication.
\end_layout

\begin_layout Section
Studied algorithm EViMA
\end_layout

\begin_layout Subsection
EViMA
\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Energy-efficient virtual-machine mapping algorithm (EViMA) focuses on improving
 resource management in the cloud data center to obtain the best task schedules
 that reduces energy consumption, execution makespan and execution cost
 without violating deadline constraints.
 
\end_layout

\begin_layout Standard
The EViMA algorithm is supported by 4 other algorithms, namely:
\end_layout

\begin_layout Itemize
Highly Critical Workflow Task Selection Algorithm (HiCTSA)
\end_layout

\begin_layout Itemize
Low Critical Task Selection Algorithm (LoCTSA)
\end_layout

\begin_layout Itemize
VM Power Regulating Algorithm (VM-PRA),
\end_layout

\begin_layout Itemize
Slack Time Harvesting Algorithm (STiHA).
 
\end_layout

\begin_layout Standard
The algorithm takes as input a set of workflow tasks represented by wt =
 (wt1, wt2, wt3, .
 .
 .
 wtn) and a set of instances (VMs) represented by (VM
\begin_inset Formula $_{HEC}$
\end_inset

, VM
\begin_inset Formula $_{MEC}$
\end_inset

, and VM
\begin_inset Formula $_{LEC}$
\end_inset

).
 The ‘‘n’’ workflow tasks can be any type of task in a queue that requires
 resources for scheduling.
 
\end_layout

\begin_layout Enumerate
The algorithm starts by identifying the arrived tasks and computing their
 expected finishing times (EFT) to determine the task execution order.
 
\end_layout

\begin_layout Enumerate
Then, a task priority queue is created in which the tasks are arranged in
 three execution orders based on their critical times (HCT, MCT, and LCT).
 To determine the execution order of the tasks, their expected finishing
 times are calculated using Eq.(4).
 The tasks that are close to their deadline and need to be mapped to VMs
 at or before their deadline are given higher priority.
 
\end_layout

\begin_layout Enumerate
To generate cost-efficient and energy-optimized schedules, a VM assignment
 order is also introduced (Line 5).
 Once both the tasks execution order and VM assignment order is established,
 we employ EViMA to explore through the various workflow tasks to find the
 overall critical tasks (HCTs), (tasks that are approaching their deadline)
 from the ready queue and immediately assign them to a high speed procession
 VM (VM
\begin_inset Formula $_{HEC}$
\end_inset

).
 This is done to find high-quality solutions to the workflow scheduling
 problem.
 For example, if wt
\begin_inset Formula $_{i}$
\end_inset

 through the searching process is found to belong to the HCT queue, Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm2_HiCTSA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\color brown
 
\color inherit
is called to assign it to a VM with high processing speed (VM
\begin_inset Formula $_{HEC}$
\end_inset

), as described in line 8.
 However, if the task belongs to the LCT group, Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm3_LoCTSA"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is called to process it, as described in line 9.
 
\end_layout

\begin_layout Enumerate
On the other hand, if the expected finishing time of the task is less than
 or equal to the harvested slack time of VMk, Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm5_STiHaM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is applied to schedule the task as in lines 15 and 16.
 
\end_layout

\begin_layout Enumerate
If the expected end time is equal to the deadline, assign the task directly
 to VM
\begin_inset Formula $_{MEC}$
\end_inset

 as in lines 11 and 12.
 Otherwise, apply Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm4_VM_PRA"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to shut down the VM when one of the VMs is idle to save power (line 18).
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
EViMA
\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
algblockdefx [Foreach] {Foreach} {EndForeach} [1] {
\backslash
textbf{foreach} #1 
\backslash
textbf{do}} {
\backslash
textbf{end foreach}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Require{Workflow, set of VMs and set of VM types $(VM_{HEC}, VM_{MEC}, VM_{LEC})
$}
\end_layout

\begin_layout Plain Layout


\backslash
State $wt_{ReadyPool} = clustered(wt_{1}, wt_{2}, wt_{3},...wt_{n})$
\end_layout

\begin_layout Plain Layout


\backslash
While{$wt_{ReadyPool} 
\backslash
neq 
\backslash
phi$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State {Compute EFT of each tasks}
\end_layout

\begin_layout Plain Layout

	
\backslash
State {Group $Tasks 
\backslash
Rightarrow $HCT, MCT, LCT}
\end_layout

\begin_layout Plain Layout

	
\backslash
State {Group $VMs 
\backslash
Rightarrow (VM_{HEC}, VM_{MEC}, VM_{LEC})$}
\end_layout

\begin_layout Plain Layout

	
\backslash
Foreach {wt in $wt_{ReadyPool}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$wt_{i}$ in HCT and $wt_{j}$ in LCT }
\end_layout

\begin_layout Plain Layout

			
\backslash
State apply algorithm 2 to execute HCT
\end_layout

\begin_layout Plain Layout

			
\backslash
State apply algorithm 3 to execute LCT 
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
If{EFT of $wt_{i}$ = Dl of $wt_{i}$}
\end_layout

\begin_layout Plain Layout

				
\backslash
State $wt_{i} 
\backslash
mapsto VM_{MEC}$
\end_layout

\begin_layout Plain Layout

				
\backslash
State Update $wt_{ReadyPool}$
\end_layout

\begin_layout Plain Layout

			
\backslash
Else
\end_layout

\begin_layout Plain Layout

				
\backslash
If{EFT of $wt_{i}$ $
\backslash
leq$ ST}
\end_layout

\begin_layout Plain Layout

					
\backslash
State apply algorithm 5
\end_layout

\begin_layout Plain Layout

				
\backslash
Else
\end_layout

\begin_layout Plain Layout

					
\backslash
State apply algorithm 4 to save mood the idle VM
\end_layout

\begin_layout Plain Layout

					
\backslash
State Update $wt_{ReadyPool}$
\end_layout

\begin_layout Plain Layout

				
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

			
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndForeach
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Highly critical task selection algorithm (HiCTSA)
\end_layout

\begin_layout Standard
Highly Critical Task Selection Algorithm (HiCTSA), presented as Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm2_HiCTSA"
plural "false"
caps "false"
noprefix "false"

\end_inset

, solve the problem of which workflow tasks should be selected first and
 to which VM and ensure that all workflow tasks meet their deadlines.
\end_layout

\begin_layout Standard
HiCTSA works at both the VM and task levels to ensure that tasks are selected
 and assigned to resources for execution to avoid delays.
 We consider a set of workflow tasks WT = (wt1, tw2, tw3..........wtn) in a workflow
 application.
 These tasks have different deadlines, and therefore users expect them to
 be executed before their deadlines.
 Also, these tasks require some resources to start the scheduling process.
\end_layout

\begin_layout Standard
Algorithm 2 starts by checking the criticality of the tasks as in line 1.Then
 compares the expected finishing time of each workflow task in the ready
 queue (line 2).
 If the expected finishing time of workflow task wt1 approaches its deadline,
 this task is marked as an HCT task (line 4).
 A mapping is then created for all HCT (line 5).
 However, if two or more tasks have the same deadline, another high speed
 VM is deployed to map those tasks (line 7 and 8).
\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
HiCTSA
\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "algorithm2_HiCTSA"

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Algorithm/EViMA_HiCTSA.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Low critical task selection algorithm (LoCTSA)
\end_layout

\begin_layout Standard
Low Critical Task Selection Algorithm (LoCTSA)
\color brown
 
\color inherit
proposed in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm3_LoCTSA"
plural "false"
caps "false"
noprefix "false"

\end_inset

,reduce the execution cost and consists of two phases:
\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\end_layout

\begin_layout Enumerate
The first phase is the task identification and grouping phase, in which
 less critical tasks are identified and queued for execution.
 In the first phase, the algorithm compares the expected finishing time
 of each workflow task with its deadline.
 If a task’s EFT is greater than its deadline, the task is moved to a new
 queue called the LCT queue (lines 1, 2, and 3).
 This is done to avoid mapping less critical tasks to HEC VM.
\end_layout

\begin_layout Enumerate
The second phase is the VM allocation phase.
 In the second phase, the quality of the solution is improved by ensuring
 that all less critical tasks are assigned to VMs with lower processing
 speed (VMs with lower cost and lower energy consumption) instead of assigning
 them to VMs with higher execution cost.
 This is done to reduce the cost of running workflow tasks.
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
LoCTSA
\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "algorithm3_LoCTSA"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/Algorithm/EViMA_LoCTSA.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
VM power regulating algorithm (VM-PRA)
\end_layout

\begin_layout Standard
VM-PRA (see Algorithm 4) check the status of all VMs used to execute workflow
 tasks.
 Sometimes,underutilized VMs are not shut down, which can increase the power
 consumption of a data center.VM-PRA overcomes this drawback by introducing
 Idle ‘‘off’’ Busy ‘‘on’’ techniques that identify the status of all VMs.
 
\end_layout

\begin_layout Standard
The method starts by defining the status of all VMs that are used for workflow
 tasks execution.
 The VMs are divided into two stages, namely a busy stage and an idle stage.
 A VM is said to be busy when it is currently executing or processing a
 workflow task.
 Idle VMs, on the other hand, are VMs that have not yet been assigned any
 job or have completed the execution process and are waiting for more jobs
 to be executed.
 The algorithm checks, if there are some idle VMs, and if so, it switches
 all idle VMs to the memory state.
 For example, when VM
\begin_inset Formula $_{HEC}$
\end_inset

 and VM
\begin_inset Formula $_{LEC}$
\end_inset

 are running and VM
\begin_inset Formula $_{MEC}$
\end_inset

is idle, the VM-PRA algorithm quickly switches VM
\begin_inset Formula $_{MEC}$
\end_inset

 into power saving mode to save some energy.
 In reality, VMs do not consume power, but when the VM is powered off or
 put into power saving mode, it reduces the power consumption of its PM,
 and hence a reduction in data center power consumption.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
VM-PRA
\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "algorithm4_VM_PRA"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/Algorithm/EViMA_VM_PRA.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Slack time harvesting method (STiHaM)
\end_layout

\begin_layout Standard
Slack time is a time interval that occurs when a particular task completes
 its execution before its actual scheduled completion time.
 In other words, it is a time difference between a task’s scheduled completion
 time and its actual completion time.
 The slack time is used to accumulate the slack times for each VM type in
 the VM pool as in line 5 of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm5_STiHaM"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 A slack time hub is attached to each VM to store the slack times of each
 VM (see line 6).
 If a slack time of VM
\begin_inset Formula $_{k}$
\end_inset

 is equal to the EFT of wt
\begin_inset Formula $_{i}$
\end_inset

, the scheduler is asked to map wt
\begin_inset Formula $_{i}$
\end_inset

 to VM
\begin_inset Formula $_{k}$
\end_inset

 to use the slack time as in lines 7 and 8 of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm5_STiHaM"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The slack time is used to further reduce the execution cost of the workflows.
 Since wti can be scheduled on VM
\begin_inset Formula $_{k}$
\end_inset

 using the obtained slack time, the cost of provisioning a new VM to schedule
 the tasks is saved
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
STiHaM
\color brown

\begin_inset CommandInset citation
LatexCommand cite
key "konjaang2022energy"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "algorithm5_STiHaM"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/Algorithm/EViMA_STiHaM.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
VM placement & VM consolidation
\end_layout

\begin_layout Subsubsection
Problem
\end_layout

\begin_layout Standard
Information and communications technology equipment (ICT) and cooling equipment
 consume most of the energy in the data centers.
 The server is the most critical ICT equipment.
 In most cases, the average CPU utilization rate of the server is only 15%
 to 20%, and there are a large number of servers in an idle state which
 consumes much energy.Therefore, VMs can be relocated into as few physical
 machines (PM) as possible through VM consolidation technology, and the
 low-load PM can be switched off.
 No-load PM can be switched to a sleep state to reduce the number of PMs
 during activities and avoid energy waste
\begin_inset CommandInset citation
LatexCommand cite
key "CHEN2023"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
In addition, the problem of low server utilization is appearing by narrow
 dynamic power ranges of servers: even completely idle servers still consume
 about 70% of their peak power.
 Therefore, keeping servers underutilized is highly inefficient from the
 energy consumption perspective.
\begin_inset CommandInset citation
LatexCommand cite
key "Al_Dulaimy2018type"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
VM Placement 
\end_layout

\begin_layout Standard
It is the process of mapping VMs to PMs.
 
\end_layout

\begin_layout Subsubsection
VM Consolidation
\end_layout

\begin_layout Standard
It refers to the replacement process using a fewer number of PMs, thus contribut
ing to energy conservation
\begin_inset CommandInset citation
LatexCommand cite
key "Al_Dulaimy2018type"
literal "false"

\end_inset

.Most of the existing methods are committed to consolidating VMs to a small
 number of servers to improve the utilization of server resources and reduce
 the total energy consumption while preventing hot-spots
\begin_inset CommandInset citation
LatexCommand cite
key "CHEN2023"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Dynamic VM consolidation follows a distributed model, where the problem
 is divided into 4 sub-problems
\begin_inset CommandInset citation
LatexCommand cite
key "Al_Dulaimy2018type"
literal "false"

\end_inset

:
\end_layout

\begin_layout Enumerate

\series bold
Host under-load detection:
\series default
 Determining if a host is considered to be under-loaded, so that all VMs
 should be migrated, and the host should be switched to a low-power mode.There
 are 2 methods:
\end_layout

\begin_deeper
\begin_layout Itemize
Static Thresholding: fixed value is set to a utilization threshold, and
 below this value, the PM is considered under-loaded.
\end_layout

\begin_layout Itemize
Dynamic Thresholding: Static Thresholding are unsuitable for a cloud computing
 environment which has dynamic, and unpredictable workloads.
 The system should be able to automatically adjust its behavior depending
 on the workload patterns, there are 2 patterns:
\end_layout

\begin_deeper
\begin_layout Itemize
Adaptive Thresholding (AT): This study proposes an Adaptive Thresholding
 (AT) technique based on statistical analysis of historical data, collected
 during the lifetime of VMs.
 AT adjusts the value of the CPU utilization threshold depending on:
\end_layout

\begin_deeper
\begin_layout Itemize
Mean Adaptive Thresholding: depending on the mean of the values of the minimum
 PMs utilization in the data center, an adaptive value is set to a utilization
 threshold.
 This value is changed frequently due to the dynamic, and the unpredictable
 workloads of the cloud environment.
\end_layout

\begin_layout Itemize
Median Adaptive Thresholding: it depends on the median.
 An adaptive value is set to a utilization threshold.
 This value is also changed frequently in a cloud environment.
\end_layout

\end_deeper
\begin_layout Itemize
Boxplot: It is one of the most frequently used graphical techniques for
 analyzing data sets, see Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "box_plot_description"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 To create a boxplot, the elements of any data set are arranged in ascending
 order.
 Then, the median value of the arranged numbers, (called in this method
 Q2), is calculated.
 Q2 divides the data into two subsets.
 To divide the data into quarters, the medians of these two subsets are
 calculated too.
 The median of the left subset is called Q1, while the median of the right
 one is called Q3.
 If the data set has an even number of elements, Q1 will be the average
 of the two middle elements.
 This works with the two subsets as well, if they have an even number of
 elements.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/boxplot.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Description of the Boxplot Method
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "box_plot_description"

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Host overload detection:
\series default
 Determining if a host is considered to be overloaded, so that some VMs
 should be migrated to other active, or reactivated hosts, to meet the QoS
 requirements.There are 2 methods which was explicated before:
\end_layout

\begin_deeper
\begin_layout Itemize
Static Thresholding.
\end_layout

\begin_layout Itemize
Dynamic Thresholding: there are 2 patterns:
\end_layout

\begin_deeper
\begin_layout Itemize
Adaptive Thresholding (AT).
\end_layout

\begin_deeper
\begin_layout Itemize
Mean Adaptive Thresholding: depending on the mean of the values of the maximum
 PMs utilization in the data center, an adaptive value is set to a utilization
 threshold.
\end_layout

\begin_layout Itemize
Median Adaptive Thresholding: it depends on the median of the values of
 the maximum PMs utilization in the data center.
\end_layout

\end_deeper
\begin_layout Itemize
Boxplot (we will use this method in our approach).
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
VM selection:
\series default
 Selecting VMs that would be migrated from an under/ overloaded hosts.There
 are many policies:
\end_layout

\begin_deeper
\begin_layout Itemize
Random Sampling (RS) Policy
\end_layout

\begin_layout Itemize
Systematic Sampling (SS) Policy
\end_layout

\begin_layout Itemize
Minimum Time Cost Migration (MTCM) Policy
\end_layout

\begin_layout Itemize
Minimum Energy Cost Migration (MECM) Policy (we will use this method in
 our approach, see Algorithm.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "Algorithm_MECM"
plural "false"
caps "false"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Algorithm of MECM
\begin_inset CommandInset label
LatexCommand label
name "Algorithm_MECM"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Algorithm/MECM.png

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
VM placement:
\series default
 Placing VMs selected for migration to other active, or reactivated hosts.To
 enhance the energy efficiency in virtualized cloud data centers, it could
 be noted that the approaches with conditional VM placement are much better
 compared with random VM placement approaches.
 The conditional VM placement approaches results in better energy efficiency
\begin_inset CommandInset citation
LatexCommand cite
key "Al_Dulaimy2018type"
literal "false"

\end_inset

.We will use VM algorithm placement based on KP (see Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:VM-placement-KP"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
VM placement based on KP
\begin_inset CommandInset label
LatexCommand label
name "alg:VM-placement-KP"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Algorithm/VM_placement_KP.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Proposed approach
\end_layout

\begin_layout Subsection
Objectives
\end_layout

\begin_layout Standard
The objective of our project is to provide a workflow scheduling mechanism
 in Cloud Computing.
 We propose an approach that consists of managing the available resources
 within a Cloud Computing system in the most efficient way possible and
 properly assigning tasks to virtual machines in order to minimize cost,
 makespan and energy without violating the deadline constraints established
 for each task by the user, in order to satisfy QoS.
\end_layout

\begin_layout Standard
So, this approach consider the following metrics and constraint:
\end_layout

\begin_layout Itemize
Energy consumption
\end_layout

\begin_layout Itemize
Cost
\end_layout

\begin_layout Itemize
Maskespan
\end_layout

\begin_layout Subsection
Principle and description
\end_layout

\begin_layout Standard
Our proposed approach is a version of the EViMA algorithm with the addition
 of a VM placement algorithm.
\end_layout

\begin_layout Itemize
We suggest doing workflow partitioning and grouping tasks in same partition
 as just one task, this can reduce the scheduling time.
\end_layout

\begin_layout Itemize
We suggest starting the EViMA algorithm first for scheduling scientific
 workflows.
\end_layout

\begin_layout Itemize
We think that when the PM is under-loaded or overloaded, it will consume
 more energy this why we think that if we apply during execution some of
 virtual machine migration strategies and plicies as in this article 
\begin_inset CommandInset citation
LatexCommand cite
key "Al_Dulaimy2018type"
literal "false"

\end_inset

,may be we will avoid this problem and so reducing energy consumed by PM.
 After seeing the results of experiments and test performance 
\begin_inset CommandInset citation
LatexCommand cite
key "Al_Dulaimy2018type"
literal "false"

\end_inset

, so we decide to apply the best pilicies which are:
\end_layout

\begin_deeper
\begin_layout Itemize
Boxplot: for both 
\series bold
host overload and under-load detection
\end_layout

\begin_layout Itemize
MECM for 
\series bold
VM selection
\end_layout

\begin_layout Itemize
We will use classical Knapsack Problem (KP) for 
\series bold
VM placement
\end_layout

\end_deeper
\begin_layout Subsection
Steps of our approach
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Our approach
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
algblockdefx [Foreach] {Foreach} {EndForeach} [1] {
\backslash
textbf{foreach} #1 
\backslash
textbf{do}} {
\backslash
textbf{end foreach}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Require{Workflow, set of VMs and set of VM types $(VM_{HEC}, VM_{MEC}, VM_{LEC})
$, PMs}
\end_layout

\begin_layout Plain Layout


\backslash
State $wt_{ReadyPool} = clustered(wt_{1}, wt_{2}, wt_{3},...wt_{n})$
\end_layout

\begin_layout Plain Layout


\backslash
State apply algorithm EViMA
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
State $VM_{candidateList} = 
\backslash
phi$
\end_layout

\begin_layout Plain Layout


\backslash
State add all VMs that are in under-loaded PMs to $VM_{candidateList}$
\end_layout

\begin_layout Plain Layout


\backslash
State add all VMs that are in over-loaded PMs to $VM_{candidateList}$
\end_layout

\begin_layout Plain Layout


\backslash
State While $VM_{candidateList}$ is not empty
\end_layout

\begin_layout Plain Layout


\backslash
State apply algorithm 6 to selecte one VM from $VM_{candidateList}$
\end_layout

\begin_layout Plain Layout


\backslash
State apply algorithm 7 to determine emplacement of this VM
\end_layout

\begin_layout Plain Layout


\backslash
State End while
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
First, we apply EViMA approach which focuses on improving resource management
 in the cloud data center to obtain the best task schedules that reduces
 energy consumption, execution makespan and execution cost without violating
 deadline constraints.
\end_layout

\begin_layout Standard
Then, we initialize VM candidate list to an empty set, and we add add all
 VMs that are in under/over-loaded physical machines.Physical machines are
 considered as under-loaded if they are 1
\begin_inset Formula $^{st}$
\end_inset

quarter(Q1) using boxplot method (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "box_plot_description"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and are overloaded if they are great than 4
\begin_inset Formula $^{th}$
\end_inset

quarter(Q4).
\end_layout

\begin_layout Standard
After that, using algorithm MECM which calculate for each VM the expected
 migration energy and sort them in ascending order.
\end_layout

\begin_layout Standard
And finally, we map the selected VMs to suitable physical machines to do
 a VM consolidation, which will allow us to switch off the PMs which are
 not used.
\end_layout

\begin_layout Subsection

\color brown
Diagram
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
This chapter was devoted to presenting our approach, based on EViMA algorithm
 and VM placement and consolidation,to scheduling workflow tasks in a cloud
 computing environment.So in the next chapter, we will present our experiment
 and simulation in order to evaluate the performance of the solutions generated
 by the proposed algorithm.
\end_layout

\end_body
\end_document
